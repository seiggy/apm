- This project uses .NET 10 and builds with `dotnet` CLI.
    - Use `dotnet build` to compile the solution.
    - Use `dotnet test` to run all tests with xUnit.
    - Use `dotnet run --project src/Apm.Cli` to run the CLI from source.
- Unit tests use xUnit with FakeItEasy (mocking) and AwesomeAssertions (fluent assertions).
- **Test coverage principle**: When modifying existing code, add tests for the code paths you touch, on top of tests for the new functionality.
- **Development Workflow**: To run APM from source while working in other directories:
    - Build the project: `dotnet build`
    - Run directly: `dotnet run --project src/Apm.Cli -- compile --verbose --dry-run`
    - Or install as local tool: `dotnet tool install --global --add-source ./nupkg apm-cli`
    - Changes to source code require a rebuild (`dotnet build`)
- The solution must meet the functionality as explained in the [README.md](README.md) file.
- The general high-level basis to the solution is depicted in [APPROACH.md](../../APPROACH.md). 
- When developing functionality, we need to respect our own [CONTRIBUTING.md](../../CONTRIBUTING.md) file.
The architectural decisions and basis for the project in that document are only the inspiring foundation. It can and should always be challenged when needed and is not meant as the only truth, but a very useful context and grounding research.
- The project is meant for the Open Source community and should be open to contributions and follow the standards of the community.
- The project is meant to be used by developers and should be easy to use, with a focus on developer experience.
- The philosophy when architecting and implementing the project is to prime speed and simplicity over complexity. Do NOT implement backwards compatibility: ship fast. Do NOT over-engineer, but rather build a solid foundation that can be iterated on. 
- We have no users, we do not need backwards compatibility, we do not need migration guides when we ship breaking changes, we do not need to worry.
- The goal is to deliver a solid and scalable architecture but simple starting implementation. Not building something complex from the start and then having to simplify it later. Remember we are delivering a new tool to the developer community and we will need to rapidly adapt to what's really useful, evolving standards, etc. 