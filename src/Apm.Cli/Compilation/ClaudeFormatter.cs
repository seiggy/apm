using Apm.Cli.Primitives;
using Apm.Cli.Utils;

namespace Apm.Cli.Compilation;

/// <summary>Result of .claude/commands/ generation.</summary>
public class CommandGenerationResult
{
    public bool Success { get; init; }
    public Dictionary<string, string> CommandsGenerated { get; init; } = [];
    public string CommandsDir { get; init; } = "";
    public int FilesWritten { get; init; }
    public List<string> Warnings { get; init; } = [];
    public List<string> Errors { get; init; } = [];
}

/// <summary>
/// Formatter for generating CLAUDE.md files from APM primitives.
/// Generates CLAUDE.md files following Claude's Memory format.
/// Also handles generation of .claude/commands/ from APM prompts (.prompt.md files).
/// </summary>
public class ClaudeFormatter : IClaudeFormatter
{
    private const string ClaudeHeader = "<!-- Generated by APM CLI -->";

    private readonly string _baseDir;
    private readonly List<string> _warnings = [];
    private readonly List<string> _errors = [];

    public ClaudeFormatter(string baseDir = ".")
    {
        _baseDir = Path.GetFullPath(baseDir);
    }

    /// <summary>Format primitives into distributed CLAUDE.md files.</summary>
    public ClaudeCompilationResult FormatDistributed(
        PrimitiveCollection primitives,
        List<PlacementResult> placements,
        Dictionary<string, object> config)
    {
        _warnings.Clear();
        _errors.Clear();

        try
        {
            var sourceAttribution = config.TryGetValue("source_attribution", out var sa) && Convert.ToBoolean(sa);

            // Convert PlacementResult list to placement map (directory -> instructions)
            var placementMap = new Dictionary<string, List<Instruction>>();
            foreach (var p in placements)
            {
                var dir = Path.GetDirectoryName(p.AgentsPath) ?? _baseDir;
                placementMap[dir] = p.Instructions;
            }

            // Generate Claude placements
            var claudePlacements = GeneratePlacements(placementMap, primitives, sourceAttribution);

            // Generate content for each placement
            var contentMap = new Dictionary<string, string>();
            foreach (var cp in claudePlacements)
                contentMap[cp.AgentsPath] = GenerateClaudeContent(cp, primitives);

            var stats = CompileStats(claudePlacements, primitives);

            return new ClaudeCompilationResult
            {
                Placements = claudePlacements.Select(cp => new PlacementResult
                {
                    AgentsPath = cp.AgentsPath,
                    Instructions = cp.Instructions
                }).ToList(),
                ContentMap = contentMap,
                Warnings = [.. _warnings],
                Errors = [.. _errors],
                Stats = stats
            };
        }
        catch (Exception e)
        {
            _errors.Add($"CLAUDE.md formatting failed: {e.Message}");
            return new ClaudeCompilationResult
            {
                Warnings = [.. _warnings],
                Errors = [.. _errors]
            };
        }
    }

    /// <summary>Generate .claude/commands/ from APM prompt files.</summary>
    public CommandGenerationResult GenerateCommands(List<string> promptFiles, bool dryRun = false)
    {
        var commandsDir = Path.Combine(_baseDir, ".claude", "commands");
        var generatedCommands = new Dictionary<string, string>();
        var warnings = new List<string>();
        var errors = new List<string>();

        foreach (var promptPath in promptFiles)
        {
            try
            {
                var (commandName, content, parseWarnings) = TransformPromptToCommand(promptPath);
                warnings.AddRange(parseWarnings);

                if (!string.IsNullOrEmpty(content))
                    generatedCommands[Path.Combine(commandsDir, $"{commandName}.md")] = content;
            }
            catch (Exception e)
            {
                errors.Add($"Failed to transform {Path.GetFileName(promptPath)}: {e.Message}");
            }
        }

        var filesWritten = 0;
        if (!dryRun && generatedCommands.Count > 0)
        {
            try
            {
                Directory.CreateDirectory(commandsDir);
                foreach (var (path, content) in generatedCommands)
                {
                    File.WriteAllText(path, content);
                    filesWritten++;
                }
            }
            catch (Exception e)
            {
                errors.Add($"Failed to write commands: {e.Message}");
            }
        }

        return new CommandGenerationResult
        {
            Success = errors.Count == 0,
            CommandsGenerated = generatedCommands,
            CommandsDir = commandsDir,
            FilesWritten = filesWritten,
            Warnings = warnings,
            Errors = errors
        };
    }

    /// <summary>Discover all .prompt.md files in the project.</summary>
    public List<string> DiscoverPromptFiles()
    {
        var promptFiles = new List<string>();

        // .apm/prompts/
        var apmPrompts = Path.Combine(_baseDir, ".apm", "prompts");
        if (Directory.Exists(apmPrompts))
            promptFiles.AddRange(Directory.EnumerateFiles(apmPrompts, "*.prompt.md", SearchOption.AllDirectories));

        // .github/prompts/
        var githubPrompts = Path.Combine(_baseDir, ".github", "prompts");
        if (Directory.Exists(githubPrompts))
            promptFiles.AddRange(Directory.EnumerateFiles(githubPrompts, "*.prompt.md", SearchOption.AllDirectories));

        // Root directory
        promptFiles.AddRange(Directory.EnumerateFiles(_baseDir, "*.prompt.md", SearchOption.TopDirectoryOnly));

        // apm_modules
        var apmModules = Path.Combine(_baseDir, "apm_modules");
        if (Directory.Exists(apmModules))
        {
            foreach (var promptDir in Directory.EnumerateDirectories(apmModules, "prompts", SearchOption.AllDirectories))
                promptFiles.AddRange(Directory.EnumerateFiles(promptDir, "*.prompt.md", SearchOption.TopDirectoryOnly));
        }

        // Deduplicate
        return promptFiles
            .Select(Path.GetFullPath)
            .Distinct(StringComparer.OrdinalIgnoreCase)
            .ToList();
    }

    // ── Internal ─────────────────────────────────────────────────────

    private List<ClaudePlacement> GeneratePlacements(
        Dictionary<string, List<Instruction>> placementMap,
        PrimitiveCollection primitives,
        bool sourceAttribution)
    {
        var placements = new List<ClaudePlacement>();

        if (placementMap.Count == 0)
        {
            var constitution = Constitution.ReadConstitution(_baseDir);
            if (constitution is not null)
            {
                placements.Add(new ClaudePlacement
                {
                    AgentsPath = Path.Combine(_baseDir, "CLAUDE.md"),
                    Instructions = [],
                    Agents = [.. primitives.Chatmodes],
                    Dependencies = CollectDependencies()
                });
            }
        }
        else
        {
            var rootAgents = primitives.Chatmodes.ToList();

            foreach (var (dir, instructions) in placementMap)
            {
                var sourceMap = new Dictionary<string, string>();
                if (sourceAttribution)
                {
                    foreach (var inst in instructions)
                        sourceMap[inst.FilePath] = inst.Source ?? "local";
                }

                var patterns = new HashSet<string>(
                    instructions.Where(i => !string.IsNullOrEmpty(i.ApplyTo)).Select(i => i.ApplyTo));

                var isRoot = string.Equals(dir, _baseDir, StringComparison.OrdinalIgnoreCase);

                placements.Add(new ClaudePlacement
                {
                    AgentsPath = Path.Combine(dir, "CLAUDE.md"),
                    Instructions = instructions,
                    Agents = isRoot ? rootAgents : [],
                    Dependencies = isRoot ? CollectDependencies() : [],
                    CoveragePatterns = patterns,
                    SourceAttribution = sourceMap
                });
            }
        }

        return placements;
    }

    private List<string> CollectDependencies()
    {
        var dependencies = new List<string>();
        var apmModulesDir = Path.Combine(_baseDir, "apm_modules");

        if (!Directory.Exists(apmModulesDir))
            return dependencies;

        foreach (var ownerDir in Directory.EnumerateDirectories(apmModulesDir))
        {
            if (Path.GetFileName(ownerDir).StartsWith('.')) continue;

            foreach (var packageDir in Directory.EnumerateDirectories(ownerDir))
            {
                if (Path.GetFileName(packageDir).StartsWith('.')) continue;
                var owner = Path.GetFileName(ownerDir);
                var package = Path.GetFileName(packageDir);
                dependencies.Add($"@apm_modules/{owner}/{package}/CLAUDE.md");
            }
        }

        dependencies.Sort();
        return dependencies;
    }

    private string GenerateClaudeContent(ClaudePlacement placement, PrimitiveCollection primitives)
    {
        var sections = new List<string>
        {
            "# CLAUDE.md",
            ClaudeHeader,
            CompilationConstants.BuildIdPlaceholder,
            $"<!-- APM Version: {VersionInfo.GetVersion()} -->",
            ""
        };

        // Dependencies (root only)
        if (placement.Dependencies.Count > 0)
        {
            sections.Add("# Dependencies");
            sections.AddRange(placement.Dependencies);
            sections.Add("");
        }

        // Constitution (root only)
        var isRoot = string.Equals(
            Path.GetDirectoryName(placement.AgentsPath),
            _baseDir,
            StringComparison.OrdinalIgnoreCase);

        if (isRoot)
        {
            var constitution = Constitution.ReadConstitution(_baseDir);
            if (constitution is not null)
            {
                sections.Add("# Constitution");
                sections.Add("");
                sections.Add(constitution.Trim());
                sections.Add("");
            }
        }

        // Project Standards
        if (placement.Instructions.Count > 0)
        {
            sections.Add("# Project Standards");
            sections.Add("");

            var patternGroups = new Dictionary<string, List<Instruction>>();
            foreach (var inst in placement.Instructions)
            {
                if (string.IsNullOrEmpty(inst.ApplyTo)) continue;
                if (!patternGroups.TryGetValue(inst.ApplyTo, out var list))
                {
                    list = [];
                    patternGroups[inst.ApplyTo] = list;
                }
                list.Add(inst);
            }

            foreach (var (pattern, patternInstructions) in patternGroups.OrderBy(kvp => kvp.Key))
            {
                sections.Add($"## Files matching `{pattern}`");
                sections.Add("");

                foreach (var inst in patternInstructions)
                {
                    var content = inst.Content.Trim();
                    if (string.IsNullOrEmpty(content)) continue;

                    if (placement.SourceAttribution.Count > 0)
                    {
                        var source = placement.SourceAttribution.GetValueOrDefault(inst.FilePath, "local");
                        string relPath;
                        try { relPath = Path.GetRelativePath(_baseDir, inst.FilePath); }
                        catch { relPath = inst.FilePath; }
                        sections.Add($"<!-- Source: {source} {relPath} -->");
                    }

                    sections.Add(content);
                    sections.Add("");
                }
            }
        }

        // Footer
        sections.Add("---");
        sections.Add("*This file was generated by APM CLI. Do not edit manually.*");
        sections.Add("*To regenerate: `apm compile`*");
        sections.Add("");

        return string.Join("\n", sections);
    }

    private static Dictionary<string, object> CompileStats(
        List<ClaudePlacement> placements,
        PrimitiveCollection primitives)
    {
        var totalInstructions = placements.Sum(p => p.Instructions.Count);
        var totalPatterns = placements.Sum(p => p.CoveragePatterns.Count);
        var totalDeps = placements.Sum(p => p.Dependencies.Count);

        return new Dictionary<string, object>
        {
            ["claude_files_generated"] = placements.Count,
            ["total_instructions_placed"] = totalInstructions,
            ["total_patterns_covered"] = totalPatterns,
            ["total_dependencies"] = totalDeps,
            ["primitives_found"] = primitives.Count()
        };
    }

    private static (string Name, string Content, List<string> Warnings) TransformPromptToCommand(string promptPath)
    {
        var warnings = new List<string>();
        var rawContent = File.ReadAllText(promptPath);

        var fileName = Path.GetFileName(promptPath);
        var commandName = fileName.EndsWith(".prompt.md")
            ? fileName[..^".prompt.md".Length]
            : Path.GetFileNameWithoutExtension(promptPath);

        // Parse simple YAML frontmatter
        var (metadata, bodyContent) = ParseSimpleFrontmatter(rawContent);

        var claudeFrontmatter = new Dictionary<string, string>();
        if (metadata.TryGetValue("description", out var desc))
            claudeFrontmatter["description"] = desc;
        if (metadata.TryGetValue("allowed-tools", out var tools))
            claudeFrontmatter["allowed-tools"] = tools;
        else if (metadata.TryGetValue("allowedTools", out tools))
            claudeFrontmatter["allowed-tools"] = tools;
        if (metadata.TryGetValue("model", out var model))
            claudeFrontmatter["model"] = model;
        if (metadata.TryGetValue("argument-hint", out var hint))
            claudeFrontmatter["argument-hint"] = hint;
        else if (metadata.TryGetValue("argumentHint", out hint))
            claudeFrontmatter["argument-hint"] = hint;

        var content = bodyContent.Trim();

        // Append $ARGUMENTS if not present
        if (!content.Contains("$ARGUMENTS") && !System.Text.RegularExpressions.Regex.IsMatch(content, @"\$\d+"))
        {
            content += "\n\n$ARGUMENTS";
            warnings.Add($"Added $ARGUMENTS placeholder to {fileName}");
        }

        var commandContent = BuildCommandContent(claudeFrontmatter, content);
        return (commandName, commandContent, warnings);
    }

    private static string BuildCommandContent(Dictionary<string, string> frontmatter, string content)
    {
        var sections = new List<string>();

        if (frontmatter.Count > 0)
        {
            sections.Add("---");
            foreach (var (key, value) in frontmatter)
            {
                sections.Add(value.Contains(':') || value.Contains('\n')
                    ? $"{key}: \"{value}\""
                    : $"{key}: {value}");
            }
            sections.Add("---");
            sections.Add("");
        }

        sections.Add(content);
        sections.Add("");

        return string.Join("\n", sections);
    }

    private static (Dictionary<string, string> Metadata, string Body) ParseSimpleFrontmatter(string content)
    {
        var metadata = new Dictionary<string, string>();

        if (!content.StartsWith("---\n") && !content.StartsWith("---\r\n"))
            return (metadata, content);

        var lines = content.Split('\n');
        var bodyStart = -1;

        for (var i = 1; i < lines.Length; i++)
        {
            if (lines[i].Trim() == "---")
            {
                bodyStart = i + 1;
                break;
            }

            var colonIdx = lines[i].IndexOf(':');
            if (colonIdx > 0)
            {
                var key = lines[i][..colonIdx].Trim();
                var value = lines[i][(colonIdx + 1)..].Trim().Trim('"');
                metadata[key] = value;
            }
        }

        var body = bodyStart >= 0 && bodyStart < lines.Length
            ? string.Join('\n', lines.Skip(bodyStart))
            : content;

        return (metadata, body);
    }
}

/// <summary>Internal placement data for CLAUDE.md generation.</summary>
internal class ClaudePlacement
{
    public string AgentsPath { get; init; } = "";
    public List<Instruction> Instructions { get; init; } = [];
    public List<Chatmode> Agents { get; init; } = [];
    public List<string> Dependencies { get; init; } = [];
    public HashSet<string> CoveragePatterns { get; init; } = [];
    public Dictionary<string, string> SourceAttribution { get; init; } = [];
}
